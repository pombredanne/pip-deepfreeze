import shutil
import tempfile
from pathlib import Path
from typing import List

import httpx
import typer

from .pip import pip_freeze_dependencies, pip_upgrade_project
from .req_file_parser import OptionsLine, parse as parse_req_file
from .req_merge import prepare_frozen_reqs_for_upgrade
from .utils import open_with_rollback

app = typer.Typer()


class MainOptions:
    python: str


@app.command()
def sync(
    ctx: typer.Context,
    to_upgrade: List[str] = typer.Option(
        None,
        "--upgrade",
        "-u",
        metavar="DEPENDENCY",
        help=(
            "Make sure DEPENDENCY is upgraded (or downgraded) to the latest "
            "allowed version. If DEPENDENCY is not part of your application "
            "dependencies anymore, this option has no effect. "
            "This option can be repeated."
        ),
    ),
    upgrade_all: bool = typer.Option(
        False,
        "--upgrade-all",
        help=(
            "Upgrade all dependencies of your application to "
            "the latest allowed version."
        ),
        show_default=False,
    ),
    extras: List[str] = typer.Option(
        None,
        "-e",
        "--extra",
        metavar="EXTRA",
        help=("Extra to install. This option can be repeated."),
    ),
    editable: bool = typer.Option(True, help="Install the project in editable mode.",),
    uninstall: bool = typer.Option(
        False, help=("Uninstall dependencies that are not needed anymore.")
    ),
) -> None:
    requirements_frozen = Path("requirements.txt")
    requirements_in = Path("requirements.txt.in")
    # upgrade project and its dependencies, if needed
    with tempfile.NamedTemporaryFile(
        dir=".", prefix="requirements.", suffix=".txt.df", mode="w", encoding="utf-8"
    ) as constraints:
        for req_line in prepare_frozen_reqs_for_upgrade(
            requirements_frozen, upgrade_all, to_upgrade
        ):
            print(req_line, file=constraints)
        constraints.flush()
        pip_upgrade_project(
            ctx.obj.python, Path(constraints.name), editable=editable, extras=extras
        )
    # uninstall unneeded dependencies, if asked to do so
    if uninstall:
        raise NotImplementedError("--uninstall not implemented yet")
    # freeze
    with open_with_rollback(requirements_frozen) as f:
        print("# frozen requirements generated by pip-deepfreeze", file=f)
        # output pip options
        if requirements_in.exists():
            # TODO can we avoid this second parse of requirements.txt.in?
            for parsed_req_line in parse_req_file(
                str(requirements_in),
                reqs_only=False,
                recurse=True,
                strict=True,
                session=httpx.Client(),
            ):
                if isinstance(parsed_req_line, OptionsLine):
                    print(parsed_req_line.raw_line, file=f)
        # output frozen dependencies of project
        for req_line in pip_freeze_dependencies(ctx.obj.python):
            print(req_line, file=f)


@app.callback()
def callback(
    ctx: typer.Context,
    python: str = typer.Option(default="python", show_default=True, metavar="PYTHON"),
    verbose: bool = typer.Option(False, "--verbose", "-v"),
) -> None:
    """
    A better pip freeze workflow for Python application developers.
    """
    python_abspath = shutil.which(python)
    # TODO error if not python_abspath
    ctx.obj.python = python_abspath
    # TODO prompt if python is same as sys.executable


def main() -> None:
    app(obj=MainOptions())


if __name__ == "__main__":
    main()
